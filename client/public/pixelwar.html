<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PixelWar ‚Äî 10k √ó 10k Realtime Canvas</title>
    <meta name="color-scheme" content="dark light" />
    <style>
      :root {
        --bg: #0b0f14;
        --panel: #0f172a;
        --panel-2: #0a1220;
        --muted: #94a3b8;
        --text: #e5e7eb;
        --accent: #334155; /* dark slate for UI accents */
        --success: #10b981;
        --danger: #ef4444;
        --warning: #f59e0b;
        --border: #1f2937;
        --grid-bg: #e5e7eb; /* light grey blank pixels (canvas only) */
      }

      html, body { height: 100%; }
      body { margin: 0; background: radial-gradient(1200px 800px at 20% 0%, #090e19, #05070b 60%), var(--bg); color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji"; overflow: hidden; }

      /* Top bar */
      .topbar {
        position: fixed;
        top: 12px; left: 12px; right: 12px;
        display: flex; align-items: center; justify-content: space-between;
        background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px 14px;
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        box-shadow: 0 10px 30px rgba(0,0,0,0.2), inset 0 1px 0 rgba(255,255,255,0.03);
        z-index: 20;
      }
      .brand { display: flex; gap: 10px; align-items: center; font-weight: 700; letter-spacing: 0.3px; }
      .brand .logo {
        width: 28px; height: 28px; border-radius: 8px;
        background: linear-gradient(135deg, #0b1220, #0f172a);
        border: 1px solid var(--border);
        box-shadow: inset 0 0 0 1px rgba(255,255,255,0.04);
      }
      .stats { display: flex; align-items: center; gap: 12px; font-size: 12px; color: var(--muted); }
      .pill { border: 1px solid var(--border); background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01)); border-radius: 999px; padding: 6px 10px; }
      .status-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; margin-right: 6px; }

      /* Canvas container */
      #canvasWrap { position: fixed; inset: 0; }
      #viewport {
        position: absolute; inset: 0; width: 100%; height: 100%; display: block;
        cursor: grab;
        background: radial-gradient(1200px 800px at 70% 20%, rgba(51,65,85,0.12), transparent 60%),
          linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.1));
      }
      #viewport.dragging { cursor: grabbing; }

      /* Palette */
      .palette {
        position: fixed; left: 50%; transform: translateX(-50%); bottom: 16px;
        display: flex; align-items: center; gap: 12px;
        padding: 10px 12px; border: 1px solid var(--border);
        background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
        border-radius: 14px; backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
        box-shadow: 0 10px 30px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.03);
        z-index: 20;
      }
      .color { width: 32px; height: 32px; border-radius: 50%; border: 2px solid rgba(255,255,255,0.12); box-shadow: inset 0 0 0 2px rgba(0,0,0,0.25); cursor: pointer; position: relative; transition: transform 0.15s ease; }
      .color:hover { transform: translateY(-2px); }
      .color.selected { outline: 3px solid rgba(255,255,255,0.22); }
      .cooldown { font-size: 12px; color: var(--muted); padding: 6px 10px; border-radius: 999px; border: 1px solid var(--border); background: rgba(0,0,0,0.25); display: flex; align-items: center; gap: 8px; }
      .progress { width: 80px; height: 6px; border-radius: 999px; background: #0f172a; overflow: hidden; }
      .progress > i { display: block; height: 100%; width: 0%; background: linear-gradient(90deg, #1f2937, #0b1220); }

      /* DB banner */
      .banner { position: fixed; left: 50%; transform: translateX(-50%); top: 60px; z-index: 30; background: #0b1220; color: var(--text); border: 1px solid var(--border); border-radius: 12px; padding: 10px 12px; display: none; gap: 10px; align-items: center; box-shadow: 0 6px 24px rgba(0,0,0,0.28); }
      .banner.show { display: inline-flex; }
      .banner button { all: unset; cursor: pointer; color: var(--muted); padding: 4px 8px; border: 1px solid var(--border); border-radius: 8px; }

      /* Tooltip */
      .hint { position: fixed; right: 16px; bottom: 16px; color: var(--muted); font-size: 12px; opacity: 0.9; z-index: 20; }
      .kbd { border: 1px solid var(--border); border-bottom: 2px solid #0a0f1a; border-radius: 6px; padding: 2px 6px; background: #0b1220; color: #cbd5e1; }
    </style>
  </head>
  <body>
    <div class="topbar">
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div>Pixel War</div>
      </div>
      <div class="stats">
        <div class="pill" title="Realtime connection">
          <span id="rtDot" class="status-dot" style="background: #ef4444"></span>
          <span id="rtText">Offline</span>
        </div>
        <div class="pill" title="Players online">üë• <span id="onlineCount">0</span></div>
        <div class="pill" title="Database persistence">üíæ <span id="dbText">Ephemeral</span></div>
        <div id="adminPill" class="pill" style="display:none; cursor:pointer;" title="Admin cheat mode (bypass cooldown)">‚ö° Admin <span id="adminState">OFF</span></div>
      </div>
    </div>

    <div id="canvasWrap"><canvas id="viewport"></canvas></div>

    <div id="dbBanner" class="banner">
      <span>Using realtime broadcast only. To persist pixels and enable late joiners, set up the Supabase table (see console for SQL).</span>
      <button id="hideBanner">Hide</button>
    </div>

    <div class="palette" role="toolbar" aria-label="Color palette">
      <div class="color" data-color="#000000" style="background:#000000" title="Black"></div>
      <div class="color" data-color="#e74c3c" style="background:#e74c3c" title="Red"></div>
      <div class="color" data-color="#e67e22" style="background:#e67e22" title="Orange"></div>
      <div class="color" data-color="#f1c40f" style="background:#f1c40f" title="Yellow"></div>
      <div class="color" data-color="#2ecc71" style="background:#2ecc71" title="Green"></div>
      <div class="color" data-color="#3498db" style="background:#3498db" title="Blue"></div>
      <div class="color" data-color="#9b59b6" style="background:#9b59b6" title="Purple"></div>
      <div class="cooldown" title="10s cooldown per player">‚è± <span id="cooldownText">Ready</span> <span class="progress"><i id="cooldownBar"></i></span></div>
    </div>

    <div class="hint">Drag with <span class="kbd">LMB</span> or <span class="kbd">MMB</span>. Click with <span class="kbd">LMB</span> to paint. Scroll to zoom. Reset view: <span class="kbd">R</span></div>

    <script type="module">
      // PixelWar ‚Äî Standalone frontend
      // Supabase project details provided by the user:
      const SUPABASE_URL = 'https://duhpfkgszvbfahtybsjx.supabase.co';
      const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImR1aHBma2dzenZiZmFodHlic2p4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUyNTk0NjAsImV4cCI6MjA3MDgzNTQ2MH0.hmnjPapG9UBGfgjAigxMsZah_U2DYLvi031nLmd2pGg';

      // Import Supabase JS client
      import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.4';

      // --- Setup UI refs ---
      const canvas = document.getElementById('viewport');
      const ctx = canvas.getContext('2d', { alpha: false });
      const rtDot = document.getElementById('rtDot');
      const rtText = document.getElementById('rtText');
      const onlineCountEl = document.getElementById('onlineCount');
      const dbText = document.getElementById('dbText');
      const dbBanner = document.getElementById('dbBanner');
      const hideBannerBtn = document.getElementById('hideBanner');
      const cooldownText = document.getElementById('cooldownText');
      const cooldownBar = document.getElementById('cooldownBar');
      const adminPill = document.getElementById('adminPill');
      const adminStateEl = document.getElementById('adminState');

      hideBannerBtn.addEventListener('click', () => dbBanner.classList.remove('show'));

      // --- Constants ---
      const WORLD_W = 10000, WORLD_H = 10000; // 10k x 10k
      const COOLDOWN_MS = 10_000; // 10s per player
      const BG_COLOR = getComputedStyle(document.documentElement).getPropertyValue('--grid-bg').trim() || '#e5e7eb';
      const MIN_SCALE = 0.25, MAX_SCALE = 20; // zoom bounds

      // --- Player identity (anonymous, local) ---
      const playerId = (() => {
        const k = 'pixelwar_player_id';
        let v = localStorage.getItem(k);
        if (!v) { v = (crypto.randomUUID ? crypto.randomUUID() : (Math.random().toString(36).slice(2) + Date.now())); localStorage.setItem(k, v); }
        return v;
      })();

      // --- Supabase init ---
      const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
        auth: { persistSession: true, autoRefreshToken: true },
        realtime: { params: { eventsPerSecond: 10 } }
      });

      // Presence & broadcast channel (works without DB)
      const channel = supabase.channel('pixelwar', { config: { broadcast: { ack: true }, presence: { key: playerId } } });

      channel.on('presence', { event: 'sync' }, () => {
        const state = channel.presenceState();
        const online = Object.keys(state).length;
        onlineCountEl.textContent = online.toString();
      });

      function setRTStatus(ok) {
        rtDot.style.background = ok ? '#10b981' : '#ef4444';
        rtText.textContent = ok ? 'Online' : 'Offline';
      }

      channel.subscribe(async status => { if (status === 'SUBSCRIBED') { setRTStatus(true); channel.track({ at: Date.now() }); } });

      // --- World state (sparse) ---
      const pixels = new Map(); // key: "x,y" -> color
      let dbEnabled = false; // flips true if the table exists and we can persist
      let drawingNeeded = true;

      // --- Viewport / camera ---
      let scale = 1; // CSS pixels per world pixel
      let camX = Math.floor(WORLD_W / 2 - 500); // initial near center
      let camY = Math.floor(WORLD_H / 2 - 400);
      let dragging = false; let dragBtn = 0; let lastMouseX = 0, lastMouseY = 0; let dragMoved = false;
      let dbLoadTimer = null; // debounce DB loads during pan/zoom

      function scheduleLoadVisibleFromDB() {
        if (!dbEnabled) return;
        clearTimeout(dbLoadTimer);
        dbLoadTimer = setTimeout(loadVisibleFromDB, 150);
      }

      function resizeCanvas() {
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const w = canvas.clientWidth, h = canvas.clientHeight;
        canvas.width = Math.floor(w * dpr);
        canvas.height = Math.floor(h * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        drawingNeeded = true;
        scheduleLoadVisibleFromDB();
      }

      function fitCanvasToContainer() {
        const wrap = document.getElementById('canvasWrap');
        canvas.style.width = wrap.clientWidth + 'px';
        canvas.style.height = wrap.clientHeight + 'px';
      }

      window.addEventListener('resize', () => { fitCanvasToContainer(); resizeCanvas(); });
      fitCanvasToContainer(); resizeCanvas();

      // --- Drawing ---
      function clearBackground(width, height) {
        ctx.fillStyle = BG_COLOR;
        ctx.fillRect(0, 0, width, height);
      }

      function drawGrid(x0, y0, x1, y1, width, height) {
        // Thin, subtle grid over all visible pixel boundaries
        ctx.save();
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'rgba(0,0,0,0.08)';
        ctx.beginPath();
        // Vertical lines
        for (let x = x0; x <= x1 + 1; x++) {
          const sx = Math.floor((x - camX) * scale) + 0.5; // pixel-align
          ctx.moveTo(sx, 0);
          ctx.lineTo(sx, height);
        }
        // Horizontal lines
        for (let y = y0; y <= y1 + 1; y++) {
          const sy = Math.floor((y - camY) * scale) + 0.5;
          ctx.moveTo(0, sy);
          ctx.lineTo(width, sy);
        }
        ctx.stroke();
        ctx.restore();
      }

      function draw() {
        if (!drawingNeeded) return;
        drawingNeeded = false;
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        clearBackground(width, height);

        // Visible rect in world coords
        const x0 = Math.max(0, Math.floor(camX));
        const y0 = Math.max(0, Math.floor(camY));
        const x1 = Math.min(WORLD_W - 1, Math.floor(camX + width / scale));
        const y1 = Math.min(WORLD_H - 1, Math.floor(camY + height / scale));

        // Batch draw by color
        const byColor = new Map();
        for (const [key, color] of pixels) {
          const idx = key.indexOf(',');
          const x = key.slice(0, idx) | 0;
          const y = key.slice(idx + 1) | 0;
          if (x < x0 || x > x1 || y < y0 || y > y1) continue;
          if (!byColor.has(color)) byColor.set(color, []);
          byColor.get(color).push(x, y);
        }
        for (const [color, arr] of byColor) {
          ctx.fillStyle = color;
          const w = Math.max(1, Math.ceil(scale));
          const h = Math.max(1, Math.ceil(scale));
          for (let i = 0; i < arr.length; i += 2) {
            const x = arr[i], y = arr[i + 1];
            const vx = Math.floor((x - camX) * scale);
            const vy = Math.floor((y - camY) * scale);
            ctx.fillRect(vx, vy, w, h);
          }
        }

        // Grid overlay
        drawGrid(x0, y0, x1, y1, width, height);
      }

      function rafLoop() { draw(); requestAnimationFrame(rafLoop); }
      requestAnimationFrame(rafLoop);

      // --- Input handling ---
      function clampCam() {
        const w = canvas.clientWidth, h = canvas.clientHeight;
        camX = Math.max(0, Math.min(WORLD_W - w / scale, camX));
        camY = Math.max(0, Math.min(WORLD_H - h / scale, camY));
      }

      canvas.addEventListener('mousedown', (e) => {
        const btn = e.button; // 0 LMB, 1 MMB, 2 RMB
        if (btn === 0 || btn === 1) {
          dragging = true; dragBtn = btn === 0 ? 1 : 2;
          lastMouseX = e.clientX; lastMouseY = e.clientY; dragMoved = false;
          canvas.classList.add('dragging');
        }
      });
      window.addEventListener('mouseup', async (e) => {
        if (!dragging) return;
        const wasLMB = (dragBtn === 1);
        const moved = dragMoved;
        dragging = false; dragBtn = 0; canvas.classList.remove('dragging');
        if (wasLMB && !moved) {
          const { x, y } = screenToWorld(e.clientX, e.clientY);
          await tryPaintPixel(x, y);
        }
      });
      window.addEventListener('mousemove', (e) => {
        if (!dragging) return;
        const dx = e.clientX - lastMouseX;
        const dy = e.clientY - lastMouseY;
        if (Math.abs(dx) > 2 || Math.abs(dy) > 2) dragMoved = true;
        lastMouseX = e.clientX; lastMouseY = e.clientY;
        camX -= dx / scale; camY -= dy / scale;
        clampCam(); drawingNeeded = true; scheduleLoadVisibleFromDB();
      });
      canvas.addEventListener('click', e => e.preventDefault());
      canvas.addEventListener('contextmenu', e => e.preventDefault());
      // Zoom with wheel (cursor-centered)
      canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        const worldX = camX + mx / scale;
        const worldY = camY + my / scale;
        const factor = Math.exp(-e.deltaY * 0.0015);
        const newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale * factor));
        if (newScale === scale) return;
        scale = newScale;
        camX = worldX - mx / scale;
        camY = worldY - my / scale;
        clampCam(); drawingNeeded = true; scheduleLoadVisibleFromDB();
      }, { passive: false });

      // Reset view
      window.addEventListener('keydown', async (e) => {
        if (e.key.toLowerCase() === 'r') {
          camX = Math.floor(WORLD_W / 2 - canvas.clientWidth / 2 / scale);
          camY = Math.floor(WORLD_H / 2 - canvas.clientHeight / 2 / scale);
          clampCam(); drawingNeeded = true; scheduleLoadVisibleFromDB();
        }
        // Secret unlock: Ctrl+Shift+A
        if (e.key.toLowerCase() === 'a' && e.ctrlKey && e.shiftKey) {
          await promptAdminUnlock();
        }
      });

      function screenToWorld(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        const x = Math.floor((clientX - rect.left) / scale + camX);
        const y = Math.floor((clientY - rect.top) / scale + camY);
        return { x: Math.max(0, Math.min(WORLD_W - 1, x)), y: Math.max(0, Math.min(WORLD_H - 1, y)) };
      }

      // --- Palette selection ---
      const COLORS_ELEMS = Array.from(document.querySelectorAll('.palette .color'));
      let selectedColor = COLORS_ELEMS[0].dataset.color;
      function updateSelectionUI() { COLORS_ELEMS.forEach(el => el.classList.toggle('selected', el.dataset.color === selectedColor)); }
      updateSelectionUI();
      COLORS_ELEMS.forEach(el => el.addEventListener('click', () => { selectedColor = el.dataset.color; updateSelectionUI(); }));

      // --- Cooldown handling ---
      const cooldownKey = 'pixelwar_last_paint';
      let lastPaint = parseInt(localStorage.getItem(cooldownKey) || '0', 10) || 0;
      let adminUnlocked = false; let adminEnabled = false;

      function canPaint() { return adminEnabled || (Date.now() - lastPaint >= COOLDOWN_MS); }
      function setPaintNow() { lastPaint = Date.now(); localStorage.setItem(cooldownKey, String(lastPaint)); }
      function updateCooldownUI() {
        if (adminEnabled) {
          cooldownText.textContent = 'Admin';
          cooldownBar.style.width = '100%';
          cooldownBar.style.background = 'linear-gradient(90deg, #0ea5e9, #0369a1)';
          return;
        }
        const now = Date.now();
        const dt = now - lastPaint;
        if (dt >= COOLDOWN_MS) { cooldownText.textContent = 'Ready'; cooldownBar.style.width = '100%'; cooldownBar.style.background = 'linear-gradient(90deg, #1f2937, #0b1220)'; }
        else { const remain = Math.ceil((COOLDOWN_MS - dt) / 1000); cooldownText.textContent = remain + 's'; const pct = Math.max(0, Math.min(100, Math.floor((dt / COOLDOWN_MS) * 100))); cooldownBar.style.width = pct + '%'; cooldownBar.style.background = '#1f2937'; }
      }
      setInterval(updateCooldownUI, 200);
      updateCooldownUI();

      // --- Paint logic ---
      async function tryPaintPixel(x, y) {
        if (!canPaint()) return;
        const color = selectedColor;
        applyPixelLocal(x, y, color);
        if (!adminEnabled) setPaintNow();
        channel.send({ type: 'broadcast', event: 'pixel_placed', payload: { x, y, color, t: Date.now(), playerId } });
        if (dbEnabled) {
          const { error } = await supabase
            .from('pixels')
            .upsert({ x, y, color, updated_at: new Date().toISOString(), player_id: playerId }, { onConflict: 'x,y' });
          if (error) console.warn('DB upsert failed:', error);
        }
      }
      function applyPixelLocal(x, y, color) { pixels.set(`${x},${y}`, color); drawingNeeded = true; }
      channel.on('broadcast', { event: 'pixel_placed' }, (ev) => { const { x, y, color } = ev.payload || {}; if (typeof x === 'number' && typeof y === 'number' && typeof color === 'string') applyPixelLocal(x, y, color); });
    </script>
  </body>
</html>
