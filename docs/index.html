<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PixelWar ‚Äî 10k √ó 10k Realtime Canvas</title>
    <meta name="color-scheme" content="dark light" />
    <style>
      :root {
        --bg: #0d1117;
        --panel: #111827;
        --panel-2: #0b1220;
        --muted: #94a3b8;
        --text: #e5e7eb;
        --accent: #4f46e5;
        --success: #10b981;
        --danger: #ef4444;
        --warning: #f59e0b;
        --border: #1f2937;
        --grid-bg: #e5e7eb; /* light grey blank pixels */
      }

      html, body { height: 100%; }
      body {
        margin: 0;
        background: radial-gradient(1200px 800px at 20% 0%, #0a0f1a, #05070b 60%), var(--bg);
        color: var(--text);
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu,
          Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        overflow: hidden;
      }

      .topbar { position: fixed; top: 12px; left: 12px; right: 12px; display: flex; align-items: center; justify-content: space-between; background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02)); border: 1px solid var(--border); border-radius: 12px; padding: 10px 14px; backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); box-shadow: 0 10px 30px rgba(0,0,0,0.2), inset 0 1px 0 rgba(255,255,255,0.04); z-index: 20; }
      .brand { display: flex; gap: 10px; align-items: center; font-weight: 700; letter-spacing: 0.3px; }
      .brand .logo { width: 28px; height: 28px; border-radius: 8px; background: radial-gradient(8px 8px at 8px 8px, #6ee7b7, transparent 50%), radial-gradient(8px 8px at 20px 20px, #93c5fd, transparent 50%), linear-gradient(135deg, #111827, #0b1220); border: 1px solid var(--border); box-shadow: inset 0 0 0 1px rgba(255,255,255,0.05); }
      .stats { display: flex; align-items: center; gap: 12px; font-size: 12px; color: var(--muted); }
      .pill { border: 1px solid var(--border); background: linear-gradient(180deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02)); border-radius: 999px; padding: 6px 10px; }
      .status-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; margin-right: 6px; }

      #canvasWrap { position: fixed; inset: 0; }
      #viewport { position: absolute; inset: 0; width: 100%; height: 100%; display: block; cursor: grab; background: radial-gradient(1200px 800px at 70% 20%, rgba(99,102,241,0.08), transparent 60%), linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.1)); }
      #viewport.dragging { cursor: grabbing; }

      .palette { position: fixed; left: 50%; transform: translateX(-50%); bottom: 16px; display: flex; align-items: center; gap: 12px; padding: 10px 12px; border: 1px solid var(--border); background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02)); border-radius: 14px; backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); box-shadow: 0 10px 30px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.05); z-index: 20; }
      .color { width: 32px; height: 32px; border-radius: 50%; border: 2px solid rgba(255,255,255,0.15); box-shadow: inset 0 0 0 2px rgba(0,0,0,0.2); cursor: pointer; position: relative; transition: transform 0.15s ease; }
      .color:hover { transform: translateY(-2px); }
      .color.selected { outline: 3px solid rgba(79,70,229,0.9); }
      .cooldown { font-size: 12px; color: var(--muted); padding: 6px 10px; border-radius: 999px; border: 1px solid var(--border); background: rgba(0,0,0,0.2); display: flex; align-items: center; gap: 8px; }
      .progress { width: 80px; height: 6px; border-radius: 999px; background: #1f2937; overflow: hidden; }
      .progress > i { display: block; height: 100%; width: 0%; background: linear-gradient(90deg, var(--accent), #22d3ee); }

      .banner { position: fixed; left: 50%; transform: translateX(-50%); top: 60px; z-index: 30; background: #0b1220; color: var(--text); border: 1px solid var(--border); border-radius: 12px; padding: 10px 12px; display: none; gap: 10px; align-items: center; box-shadow: 0 6px 24px rgba(0,0,0,0.28); }
      .banner.show { display: inline-flex; }
      .banner button { all: unset; cursor: pointer; color: var(--muted); padding: 4px 8px; border: 1px solid var(--border); border-radius: 8px; }

      .hint { position: fixed; right: 16px; bottom: 16px; color: var(--muted); font-size: 12px; opacity: 0.9; z-index: 20; }
      .kbd { border: 1px solid var(--border); border-bottom: 2px solid #0a0f1a; border-radius: 6px; padding: 2px 6px; background: #0b1220; color: #cbd5e1; }
    </style>
  </head>
  <body>
    <div class="topbar">
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div>PixelWar</div>
      </div>
      <div class="stats">
        <div class="pill" title="Realtime connection">
          <span id="rtDot" class="status-dot" style="background: #ef4444"></span>
          <span id="rtText">Offline</span>
        </div>
        <div class="pill" title="Players online">
          üë• <span id="onlineCount">0</span>
        </div>
        <div class="pill" title="Database persistence">
          üíæ <span id="dbText">Ephemeral</span>
        </div>
      </div>
    </div>

    <div id="canvasWrap">
      <canvas id="viewport"></canvas>
    </div>

    <div id="dbBanner" class="banner">
      <span>Using realtime broadcast only. To persist pixels and enable late joiners, set up the Supabase table (see console for SQL).</span>
      <button id="hideBanner">Hide</button>
    </div>

    <div class="palette" role="toolbar" aria-label="Color palette">
      <div class="color" data-color="#000000" style="background:#000000" title="Black"></div>
      <div class="color" data-color="#e74c3c" style="background:#e74c3c" title="Red"></div>
      <div class="color" data-color="#e67e22" style="background:#e67e22" title="Orange"></div>
      <div class="color" data-color="#f1c40f" style="background:#f1c40f" title="Yellow"></div>
      <div class="color" data-color="#2ecc71" style="background:#2ecc71" title="Green"></div>
      <div class="color" data-color="#3498db" style="background:#3498db" title="Blue"></div>
      <div class="color" data-color="#9b59b6" style="background:#9b59b6" title="Purple"></div>
      <div class="cooldown" title="10s cooldown per player">
        ‚è± <span id="cooldownText">Ready</span>
        <span class="progress"><i id="cooldownBar"></i></span>
      </div>
    </div>

    <div class="hint">Drag with <span class="kbd">LMB</span> or <span class="kbd">MMB</span>. Click with <span class="kbd">LMB</span> to paint. Scroll to zoom. Reset view: <span class="kbd">R</span></div>

    <script type="module">
      const SUPABASE_URL = 'https://duhpfkgszvbfahtybsjx.supabase.co';
      const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImR1aHBma2dzenZiZmFodHlic2p4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUyNTk0NjAsImV4cCI6MjA3MDgzNTQ2MH0.hmnjPapG9UBGfgjAigxMsZah_U2DYLvi031nLmd2pGg';

      import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.4';

      const canvas = document.getElementById('viewport');
      const ctx = canvas.getContext('2d', { alpha: false });
      const rtDot = document.getElementById('rtDot');
      const rtText = document.getElementById('rtText');
      const onlineCountEl = document.getElementById('onlineCount');
      const dbText = document.getElementById('dbText');
      const dbBanner = document.getElementById('dbBanner');
      const hideBannerBtn = document.getElementById('hideBanner');
      const cooldownText = document.getElementById('cooldownText');
      const cooldownBar = document.getElementById('cooldownBar');

      hideBannerBtn.addEventListener('click', () => dbBanner.classList.remove('show'));

      const WORLD_W = 10000, WORLD_H = 10000;
      const COOLDOWN_MS = 10_000;
      const BG_COLOR = getComputedStyle(document.documentElement).getPropertyValue('--grid-bg').trim() || '#e5e7eb';
      const MIN_SCALE = 0.25, MAX_SCALE = 20;

      const playerId = (() => { const k = 'pixelwar_player_id'; let v = localStorage.getItem(k); if (!v) { v = (crypto.randomUUID ? crypto.randomUUID() : (Math.random().toString(36).slice(2) + Date.now())); localStorage.setItem(k, v); } return v; })();

      const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, { auth: { persistSession: true, autoRefreshToken: true }, realtime: { params: { eventsPerSecond: 10 } } });
      const channel = supabase.channel('pixelwar', { config: { broadcast: { ack: true }, presence: { key: playerId } } });

      channel.on('presence', { event: 'sync' }, () => { const state = channel.presenceState(); onlineCountEl.textContent = String(Object.keys(state).length); });
      function setRTStatus(ok) { rtDot.style.background = ok ? '#10b981' : '#ef4444'; rtText.textContent = ok ? 'Online' : 'Offline'; }
      channel.subscribe(async status => { if (status === 'SUBSCRIBED') { setRTStatus(true); channel.track({ at: Date.now() }); } });

      const pixels = new Map();
      let dbEnabled = false; let drawingNeeded = true;

      let scale = 1; let camX = Math.floor(WORLD_W / 2 - 500); let camY = Math.floor(WORLD_H / 2 - 400);
      let dragging = false; let dragBtn = 0; let lastMouseX = 0, lastMouseY = 0; let dragMoved = false; let dbLoadTimer = null;

      function scheduleLoadVisibleFromDB() { if (!dbEnabled) return; clearTimeout(dbLoadTimer); dbLoadTimer = setTimeout(loadVisibleFromDB, 150); }
      function resizeCanvas() { const dpr = Math.max(1, window.devicePixelRatio || 1); const w = canvas.clientWidth, h = canvas.clientHeight; canvas.width = Math.floor(w * dpr); canvas.height = Math.floor(h * dpr); ctx.setTransform(dpr, 0, 0, dpr, 0, 0); drawingNeeded = true; scheduleLoadVisibleFromDB(); }
      function fitCanvasToContainer() { const wrap = document.getElementById('canvasWrap'); canvas.style.width = wrap.clientWidth + 'px'; canvas.style.height = wrap.clientHeight + 'px'; }
      window.addEventListener('resize', () => { fitCanvasToContainer(); resizeCanvas(); }); fitCanvasToContainer(); resizeCanvas();

      function clearBackground(width, height) { ctx.fillStyle = BG_COLOR; ctx.fillRect(0, 0, width, height); }
      function drawGrid(x0, y0, x1, y1, width, height) { ctx.save(); ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(0,0,0,0.08)'; ctx.beginPath(); for (let x = x0; x <= x1 + 1; x++) { const sx = Math.floor((x - camX) * scale) + 0.5; ctx.moveTo(sx, 0); ctx.lineTo(sx, height); } for (let y = y0; y <= y1 + 1; y++) { const sy = Math.floor((y - camY) * scale) + 0.5; ctx.moveTo(0, sy); ctx.lineTo(width, sy); } ctx.stroke(); ctx.restore(); }
      function draw() { if (!drawingNeeded) return; drawingNeeded = false; const width = canvas.clientWidth; const height = canvas.clientHeight; clearBackground(width, height); const x0 = Math.max(0, Math.floor(camX)); const y0 = Math.max(0, Math.floor(camY)); const x1 = Math.min(WORLD_W - 1, Math.floor(camX + width / scale)); const y1 = Math.min(WORLD_H - 1, Math.floor(camY + height / scale)); const byColor = new Map(); for (const [key, color] of pixels) { const idx = key.indexOf(','); const x = key.slice(0, idx) | 0; const y = key.slice(idx + 1) | 0; if (x < x0 || x > x1 || y < y0 || y > y1) continue; if (!byColor.has(color)) byColor.set(color, []); byColor.get(color).push(x, y); } for (const [color, arr] of byColor) { ctx.fillStyle = color; const w = Math.max(1, Math.ceil(scale)); const h = Math.max(1, Math.ceil(scale)); for (let i = 0; i < arr.length; i += 2) { const x = arr[i], y = arr[i + 1]; const vx = Math.floor((x - camX) * scale); const vy = Math.floor((y - camY) * scale); ctx.fillRect(vx, vy, w, h); } } drawGrid(x0, y0, x1, y1, width, height); }
      function rafLoop() { draw(); requestAnimationFrame(rafLoop); } requestAnimationFrame(rafLoop);

      function clampCam() { const w = canvas.clientWidth, h = canvas.clientHeight; camX = Math.max(0, Math.min(WORLD_W - w / scale, camX)); camY = Math.max(0, Math.min(WORLD_H - h / scale, camY)); }
      canvas.addEventListener('mousedown', (e) => { const btn = e.button; if (btn === 0 || btn === 1) { dragging = true; dragBtn = btn === 0 ? 1 : 2; lastMouseX = e.clientX; lastMouseY = e.clientY; dragMoved = false; canvas.classList.add('dragging'); } });
      window.addEventListener('mouseup', async (e) => { if (!dragging) return; const wasLMB = (dragBtn === 1); const moved = dragMoved; dragging = false; dragBtn = 0; canvas.classList.remove('dragging'); if (wasLMB && !moved) { const { x, y } = screenToWorld(e.clientX, e.clientY); await tryPaintPixel(x, y); } });
      window.addEventListener('mousemove', (e) => { if (!dragging) return; const dx = e.clientX - lastMouseX; const dy = e.clientY - lastMouseY; if (Math.abs(dx) > 2 || Math.abs(dy) > 2) dragMoved = true; lastMouseX = e.clientX; lastMouseY = e.clientY; camX -= dx / scale; camY -= dy / scale; clampCam(); drawingNeeded = true; scheduleLoadVisibleFromDB(); });
      canvas.addEventListener('click', e => e.preventDefault());
      canvas.addEventListener('contextmenu', e => e.preventDefault());
      canvas.addEventListener('wheel', (e) => { e.preventDefault(); const rect = canvas.getBoundingClientRect(); const mx = e.clientX - rect.left; const my = e.clientY - rect.top; const worldX = camX + mx / scale; const worldY = camY + my / scale; const factor = Math.exp(-e.deltaY * 0.0015); const newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale * factor)); if (newScale === scale) return; scale = newScale; camX = worldX - mx / scale; camY = worldY - my / scale; clampCam(); drawingNeeded = true; scheduleLoadVisibleFromDB(); }, { passive: false });
      window.addEventListener('keydown', (e) => { if (e.key.toLowerCase() === 'r') { camX = Math.floor(WORLD_W / 2 - canvas.clientWidth / 2 / scale); camY = Math.floor(WORLD_H / 2 - canvas.clientHeight / 2 / scale); clampCam(); drawingNeeded = true; scheduleLoadVisibleFromDB(); } });

      function screenToWorld(clientX, clientY) { const rect = canvas.getBoundingClientRect(); const x = Math.floor((clientX - rect.left) / scale + camX); const y = Math.floor((clientY - rect.top) / scale + camY); return { x: Math.max(0, Math.min(WORLD_W - 1, x)), y: Math.max(0, Math.min(WORLD_H - 1, y)) }; }

      const COLORS_ELEMS = Array.from(document.querySelectorAll('.palette .color'));
      let selectedColor = COLORS_ELEMS[0].dataset.color; function updateSelectionUI() { COLORS_ELEMS.forEach(el => el.classList.toggle('selected', el.dataset.color === selectedColor)); } updateSelectionUI(); COLORS_ELEMS.forEach(el => el.addEventListener('click', () => { selectedColor = el.dataset.color; updateSelectionUI(); }));

      const cooldownKey = 'pixelwar_last_paint'; let lastPaint = parseInt(localStorage.getItem(cooldownKey) || '0', 10) || 0;
      function canPaint() { return Date.now() - lastPaint >= COOLDOWN_MS; }
      function setPaintNow() { lastPaint = Date.now(); localStorage.setItem(cooldownKey, String(lastPaint)); }
      function updateCooldownUI() { const now = Date.now(); const dt = now - lastPaint; if (dt >= COOLDOWN_MS) { cooldownText.textContent = 'Ready'; cooldownBar.style.width = '100%'; cooldownBar.style.background = 'linear-gradient(90deg, var(--success), #22d3ee)'; } else { const remain = Math.ceil((COOLDOWN_MS - dt) / 1000); cooldownText.textContent = remain + 's'; const pct = Math.max(0, Math.min(100, Math.floor((dt / COOLDOWN_MS) * 100))); cooldownBar.style.width = pct + '%'; cooldownBar.style.background = 'linear-gradient(90deg, var(--warning), #f59e0b)'; } }
      setInterval(updateCooldownUI, 200); updateCooldownUI();

      async function tryPaintPixel(x, y) { if (!canPaint()) return; const color = selectedColor; applyPixelLocal(x, y, color); setPaintNow(); channel.send({ type: 'broadcast', event: 'pixel_placed', payload: { x, y, color, t: Date.now(), playerId } }); if (dbEnabled) { const { error } = await supabase.from('pixels').upsert({ x, y, color, updated_at: new Date().toISOString(), player_id: playerId }, { onConflict: 'x,y' }); if (error) console.warn('DB upsert failed:', error); } }
      function applyPixelLocal(x, y, color) { pixels.set(`${x},${y}`, color); drawingNeeded = true; }
      channel.on('broadcast', { event: 'pixel_placed' }, (ev) => { const { x, y, color } = ev.payload || {}; if (typeof x === 'number' && typeof y === 'number' && typeof color === 'string') applyPixelLocal(x, y, color); });

      async function checkDB() {
        const { error } = await supabase.from('pixels').select('x').limit(1);
        if (error) {
          console.log('[PixelWar] DB not ready. Using ephemeral broadcast only.');
          console.log('--- SQL to create the table (Run in Supabase SQL Editor) ---');
          console.log(`
-- Create pixels table for PixelWar
create table if not exists public.pixels (
  x int2 not null,
  y int2 not null,
  color text not null check (char_length(color) between 4 and 9),
  updated_at timestamptz not null default now(),
  player_id uuid,
  primary key (x, y)
);

create index if not exists pixels_xy_idx on public.pixels (x, y);

-- Enable Realtime on this table in: Database -> Replication -> Configure -> Add table 'public.pixels'

alter table public.pixels enable row level security;
do $$ begin
  if not exists (select 1 from pg_policies where tablename = 'pixels' and policyname = 'allow all') then
    create policy "allow all" on public.pixels for all using (true) with check (true);
  end if;
end $$;
          `.trim());
          dbEnabled = false; dbText.textContent = 'Ephemeral'; dbBanner.classList.add('show');
        } else {
          dbEnabled = true; dbText.textContent = 'Enabled'; dbBanner.classList.remove('show');
          supabase.channel('realtime:pixels')
            .on('postgres_changes', { event: '*', schema: 'public', table: 'pixels' }, (payload) => {
              const row = payload.new || payload.record; if (!row) return;
              const { x, y, color } = row; if (typeof x === 'number' && typeof y === 'number' && typeof color === 'string') applyPixelLocal(x, y, color);
            })
            .subscribe();
        }
      }

      async function loadVisibleFromDB() {
        if (!dbEnabled) return;
        const width = canvas.clientWidth; const height = canvas.clientHeight;
        const x0 = Math.max(0, Math.floor(camX)); const y0 = Math.max(0, Math.floor(camY));
        const x1 = Math.min(WORLD_W - 1, Math.floor(camX + width / scale));
        const y1 = Math.min(WORLD_H - 1, Math.floor(camY + height / scale));
        const { data, error } = await supabase
          .from('pixels')
          .select('x,y,color')
          .gte('x', x0).lte('x', x1)
          .gte('y', y0).lte('y', y1)
          .limit(200000);
        if (error) { console.warn('DB select failed:', error); return; }
        if (Array.isArray(data)) { for (const row of data) applyPixelLocal(row.x|0, row.y|0, row.color); }
      }

      await checkDB();
      await loadVisibleFromDB();
      drawingNeeded = true;

      console.log('[PixelWar] If hosting on GitHub Pages, ensure your Supabase Realtime allows your Pages origin.');
    </script>

    <!-- See repository copy under client/public/pixelwar.html for inline SQL and comments. -->
  </body>
</html>
